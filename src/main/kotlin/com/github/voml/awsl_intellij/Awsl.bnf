{
    parserClass = "com.github.voml.awsl_intellij.language.parser.AwslParser"
    parserUtilClass = "com.github.voml.awsl_intellij.language.psi.AwslParserUtil"

    psiClassPrefix = "Awsl"
    psiImplClassSuffix = "Node"
    psiPackage = "com.github.voml.awsl_intellij.language.psi"
    psiImplPackage = "com.github.voml.awsl_intellij.language.psi_node"

    elementTypeHolderClass = "com.github.voml.awsl_intellij.language.psi.AwslTypes"
    elementTypeClass = "com.github.voml.awsl_intellij.language.psi.AwslElementType"
    tokenTypeClass = "com.github.voml.awsl_intellij.language.psi.AwslTokenType"

    psiImplUtilClass = "com.github.voml.awsl_intellij.language.psi_node.AwslPsiImplUtil"
    // Lexer Token from JFlex
    // Here only write names
    tokens = [
        // 注释
        COMMENT_LINE="Comment Line";
        COMMENT_BLOCK="Comment Block";
        COMMENT_HTML="Comment in HTML";
        COMMENT_DOCUMENT="Comment Document";
        IN="Keyword in";
        FOR="Keyword for";
        WHILE="Keyword while";
        // 符号
        COMMA=","
        STAR="*"
        ACCENT="^"
        DOLLAR="$"
        DOT="."
        AT="@"
        EQ="="
        COLON=":"
        SEMICOLON=";"
        NAME_JOIN="::"
        // 括号
        PARENTHESIS_L="("
        PARENTHESIS_R=")"
        BRACKET_L="["
        BRACKET_R="]"
        BRACE_L="{"
        BRACE_R="}"
        ANGLE_L="<"
        ANGLE_R=">"
        GENERIC_L="<"
        GENERIC_R=">"
        HTML_BEGIN_TOKEN="HTML_BEGIN_TOKEN"
        HTML_START_END_TOKEN="HTML_START_END_TOKEN"
        HTML_OPEN_END_TOKEN="HTML_OPEN_CLOSE_END_TOKEN"
        HTML_SELF_END_TOKEN="HTML_SELF_CLOSE_END_TOKEN"
        HTML_TAG_SYMBOL="Symbol::HtmlTag"
        SYMBOL="Symbol"
    ]

    extends = "com.intellij.extapi.psi.ASTWrapperPsiElement"
//    extends("(add|mul)_expr")=binary_expr
//    extends(".*_expr")=expr
//
//    mixin("HTML_END")="com.github.voml.awsl_intellij.psi.impl.AwslHtmlEndMixin"
}

Awsl ::= statement*;

private statement ::=
    COMMENT_DOCUMENT
  | SYMBOL
  | STRING
  | html_normal
  | html_self_end
 // | ignore
  ;
fake binary_expr ::= expr + {
  methods=[
    left="/expr[0]"
    right="/expr[1]"
  ]
}
// =====================================================================================================================
// <hr>
// <hr/>
html_self_end ::= HTML_BEGIN_TOKEN [html_begin_inner_head] HTML_SELF_END_TOKEN;
private html_begin_inner_head ::= HTML_TAG_SYMBOL [NAME_JOIN (SYMBOL|generic)] html_begin_inner_rest*;
private html_begin_inner_rest ::= SYMBOL EQ STRING;
generic ::= GENERIC_L (SYMBOL [generic]) GENERIC_R;
// <a>text</a>
// <\a>code</a>
html_normal ::= html_start html_inner* html_open_end;
html_start ::= HTML_BEGIN_TOKEN html_begin_inner_head HTML_START_END_TOKEN;
html_open_end ::= HTML_BEGIN_TOKEN html_begin_inner_head HTML_OPEN_END_TOKEN;
private html_inner ::= STRING | html_self_end | html_open_end | SYMBOL;



// =====================================================================================================================
// parenthesis ( )
private meta parenthesis ::= PARENTHESIS_L <<param>> PARENTHESIS_R;
// bracket [ ]
meta bracket_block ::= BRACKET_L [<<item>> (<<sp>> <<item>>)* [<<sp>>]] BRACKET_R;
// brace { }
meta brace_block ::= BRACE_L (<<item>>|<<sp>>)* BRACE_R;

